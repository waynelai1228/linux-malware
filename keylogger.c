#include <stdio.h>
#include <fcntl.h>
#include <linux/input.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>

void INThandler(){
        exit(0);
}

int main(int argc, char** argv) {
  FILE* dev_file = fopen("/proc/bus/input/devices", "r");

  if (dev_file == NULL) {
    perror("Cannot open device file");
  }

  char handler_str[] = {'H', ':', ' ', 'H', 'a', 'n', 'd', 'l', 'e', 'r', 's'};
  char sysrq_str[] = {'s', 'y', 's', 'r', 'q'};
  char kbd_str[] = {'k', 'b', 'd'};
  char dev_input_file[] = {'/', 'd', 'e', 'v', '/', 'i', 'n', 'p', 'u', 't', '/', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};
  char event_str[10];
  char buffer[256];

  // go through every line in the device file
  while(fgets(buffer, 256, dev_file) != NULL){
    // check if the particular line is the handler line
    char handler_line = 1;
    for (int i = 0; i < 11; i++) {
      // the line is not what we want
      if (handler_str[i] != buffer[i]) {
        handler_line = 0;
        break;
      }
    }

    // if we are looking at a handler line
    if (handler_line) {
      // check that both "kbd" and "sysrq" appear in this line
      char kbd_present = 0;
      char sysrq_present = 0;
      char kbd_index= 0;
      char sysrq_index= 0;
      // go through each character; terminate at buffer length or new line
      for (int i = 0; i < 256 && buffer[i] != '\n'; i++) {
        // check the next character of kbd_str if current character match
        if (kbd_str[kbd_index] == buffer[i]) {
          kbd_index++;
          // the string is in the line
          if (kbd_index == 3) {
            kbd_present = 1;
          }
        }
        else {
          kbd_index = 0;
        }

        // check the next character of sysrq_str if current character match
        if (sysrq_str[sysrq_index] == buffer[i]) {
          sysrq_index++;
          // the string is in the line
          if (sysrq_index == 5) {
            sysrq_present = 1;
          }
        }
        else {
          sysrq_index = 0;
        }

        // no need to check if both sysrq_str and kbd_str appears in the line
        if (kbd_present && sysrq_present) {
          break;
        }
      }
      
      if (kbd_present && sysrq_present) {
        event_str[0] = 'e';
        event_str[1] = 'v';
        event_str[2] = 'e';
        event_str[3] = 'n';
        event_str[4] = 't';
        event_str[5] = '\0';
        event_str[6] = '\0';
        event_str[7] = '\0';
        event_str[8] = '\0';
        event_str[9] = '\0';
        char event_index = 0;
        char event_str_index = 0;
        for (int i = 0; i < 256 && buffer[i] != '\n'; i++) {
          if (event_str[event_index] == buffer[i]) {
            event_index++;
            if (event_index == 5) {
              event_str_index = i;
              break;
            }
          }
        }
        printf("%s", buffer + event_str_index);
        for (int i = event_str_index + 1; i < event_str_index + 5 && buffer[i] != ' '; i++) {
          event_str[i - event_str_index + 4] = buffer[i];
        }

        printf("%s\n", event_str);
        if (event_str[5] != '\0') {
          break;
        }
      }
    }
  }

  printf("%s\n", event_str);
  for (int i = 11; i < 21; i++) {
    dev_input_file[i] = event_str[i - 11];
  }
  printf("%s\n", dev_input_file);

  int device = open(dev_input_file, O_RDONLY);

  if (device == NULL) {
    perror("Could not open device input file");
  }

  struct input_event ev;

  signal(SIGINT, INThandler);

  while (1) {
    read(device, &ev, sizeof(ev));
    if(ev.type == 1 && ev.value == 1) {
      printf("Key: %i State: %i\n", ev.code, ev.value);
    }
  }

  fclose(dev_file);
}
